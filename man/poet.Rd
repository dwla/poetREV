% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{poet}
\alias{poet}
\title{POET Revised by Wenliang Ding}
\usage{
poet(Y, K = NULL, C = 0.5, thres = "soft", matrix = "cor")
}
\arguments{
\item{Y}{p by n matrix of raw data, where p is the dimensionality, n is the
sample size. It is recommended that Y is de-meaned, i.e., each row has
zero mean.}

\item{K}{number of factors. K is pre-determined by the users. Default value
  is set at the average value obtained from the Hallin&Liska and Bai&Ng
  methods. Suggestions on choosing K:

A simple way of determining K is to count the number of very spiked (much
larger than others) eigenvalues of the p by p sample covariance matrix of Y.

A formal data-driven way of determining K is described in Bai and Ng
(2002):"Determining the number of factors in approximate factor models",
Econometrica, 70, 191-221. This procedure requires a one-dimensional
optimization.

POET is very robust to over-estimating K. But under-estimating K can result
to VERY BAD performance. Therefore we strongly recommend choosing a
relatively large K (normally less than 8) to avoid missing any important
common factor.

K=0 corresponds to threshoding the sample covariance directly.}

\item{C}{the positive constant for thresholding, user-specified. Default
value is set at C=0.5 Our experience shows that C=0.5 performs quite well
for soft thresholding.}

\item{thres}{choice of thresholding. Users can choose from three
  thresholding methods:

'soft': soft thresholding;

'hard' hard thresholding;

'scad': scad thresholding;

('alasso': adaptive lasso thresholding; we don't have this option)

Default value is set at thres='soft'.

Details are found in Rothman et al. (2009): "Generalized thresholding of large covariance matrices." JASA, 104, 177-186}

\item{matrix}{the option of thresholding either correlation or covairance matrix. Users can choose from:

'cor': threshold the error correlation matrix then transform back to covariance matrix

'vad': threshold the error covariance matrix directly.

Default value is set at matrix='cor'.}
}
\value{
A list with two elements
\item{SigmaY}{estimated p by p covariance matrix of y_t}
\item{SigmaU}{estimated p by p covariance matrix of u_t}
\item{factors}{estimated K by n factor matrix of f_t}
\item{loadings}{estimated p by K loading matrix, i.e. the B in Y_t=Bf_t+u_t}
}
\description{
Estimates large covariance matrices in approximate factor models by
thresholding principal orthogonal complements.
}
\details{
(Copy from POET package) This function is for POET, proposed by Fan, Liao
and Mincheva (2012) 'Large Covariance Estimation by Thresholding Principal
Orthogonal Complements', manuscript of Princeton University

Model: Y_t=Bf_t+u_t, where B, f_t and u_t represent factor loading matrix,
common factors and idiosyncratic error respectively. Only Y_t is
observable. t=1,...,n. Dimension of Y_t is p. The goal is to estimate the
covariance matrices of Y_t and u_t.

Note: (1) POET is optimization-free, so no initial value, tolerant, or
maximum iterations need to be specified as inputs.

(2) We can apply the adaptive thresholding (Cai and Liu 2011, JASA) on
either the correlation matrix or the covariance matrix, specified by the
option 'matrix'.

(3) If no factor structure is assumed, i.e., no common factors exist and
var(Y_t) itself is sparse, set K=0.

IMPORTANT: the calculation of Hallin & Liska method (2007) is wrong in the
original POET package, here we only calculate the criteria from Bai & Ng
(2002).
}
\examples{
n <- 50; p <- 100
set.seed(1)
Y <- t(MASS::mvrnorm(n, rep(0, p), diag(1, p)))
res_poet <- poetREV::poet(Y, NULL, .5, "soft", "cor")
## res_poet$SigmaY
## res_poet$SigmaU
res_poet2 <- poetREV::poet2(Y, -Inf, .5, "soft", "cor")
## res_poet2$SigmaY
## res_poet2$SigmaU
mean(abs(res_poet$SigmaY - res_poet2$SigmaY)) ## [1] 5.15726e-16
mean(abs(res_poet$SigmaU - res_poet2$SigmaU)) ## [1] 1.015261e-16

## POET paper, Eq.(2.10)
res_poet$factors \%*\% t(res_poet$factors) / n
res_poet2$factors \%*\% t(res_poet2$factors) / n
cov(t(res_poet$factors))
cov(t(res_poet$factors)) * (n-1) / n
cov(t(res_poet2$factors))
cov(t(res_poet2$factors)) * (n-1) / n

## The difference comes from the different algorithm of SVD used in R and Cpp
mean(abs(res_poet$factors - res_poet2$factors)) ## [1] 0.7913238
mean(abs(res_poet$loadings - res_poet2$loadings)) ## [1] 0.1898726

## But for the identification of B f_t and the Lowrank part B SigmaF B' is
## almost the same, no matter R or Cpp is used.
mean(abs(
    res_poet$loadings \%*\% res_poet$factors -
    res_poet2$loadings \%*\% res_poet2$factors
)) ## [1] 2.580809e-15
mean(abs(
    res_poet$loadings \%*\% cov(t(res_poet$factors)) \%*\% t(res_poet$loadings) -
    res_poet2$loadings \%*\% cov(t(res_poet2$factors)) \%*\% t(res_poet2$loadings)
)) ## [1] 7.02809e-16

## For the selection of C, refer to Figure 1 in Page 8 of
## https://arxiv.org/pdf/1504.02995, An Overview on the Estimation of Large
## Covariance and Precision Matrices
poet_Cmin(Y, K = 3, "soft", "cor")
poet_Cmin(Y, K = 0, "soft", "cor")
poet_Cmin(Y, K = 3, "hard", "cor")
poet_Cmin(Y, K = 0, "hard", "cor")
poet_Cmin(Y, K = 3, "scad", "cor")
poet_Cmin(Y, K = 0, "scad", "cor")
## [1] 0.2247936
## [1] 0.2848489
## [1] 0.8702903
## [1] 1.116082
## [1] 0.3395239
## [1] 0.4395344

poet_Cmin(Y, K = 3, "soft", "vad")
poet_Cmin(Y, K = 0, "soft", "vad")
poet_Cmin(Y, K = 3, "hard", "vad")
poet_Cmin(Y, K = 0, "hard", "vad")
poet_Cmin(Y, K = 3, "scad", "vad")
poet_Cmin(Y, K = 0, "scad", "vad")
## [1] 0.2142127
## [1] 0.2686194
## [1] 0.8631784
## [1] 1.187616
## [1] 0.4448349
}
\references{
Fan, J., Liao, Y., & Mincheva, M. (2013). Large covariance estimation by thresholding principal orthogonal complements. Journal of the Royal Statistical Society Series B: Statistical Methodology, 75(4), 603-680.
}
